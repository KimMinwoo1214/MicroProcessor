/*
// PWM 폭(us)
volatile int roll_us     = 1500;
volatile int pitch_us    = 1500;
volatile int throttle_us = 1000;
volatile int yaw_us      = 1500;

String inputString = "";

#define ROLL_PIN     9    
#define PITCH_PIN    10   
#define THROTTLE_PIN 3    
#define YAW_PIN      5    

void setup() {
  Serial.begin(9600);

  pinMode(ROLL_PIN, OUTPUT);
  pinMode(PITCH_PIN, OUTPUT);
  pinMode(THROTTLE_PIN, OUTPUT);
  pinMode(YAW_PIN, OUTPUT);                                                       //완성 후 DDRx, PORTx 로 바꾸기
  

  // Timer1 설정: 0.5us 해상도로 CTC 모드
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;

  TCCR1B |= (1 << WGM12);  // CTC 모드
  TCCR1B |= (1 << CS11);   // 프리스케일러 8 → 2MHz → 0.5us 해상도
  OCR1A = 40000;           // 20ms = 40000 × 0.5us
  TIMSK1 |= (1 << OCIE1A); 
  sei();
}

void loop() {
  // 블루투스 문자열 수신
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n') {
      parseCommand(inputString);
      inputString = "";
    } else {
      inputString += c;
    }
  }
}

// 20ms마다 PWM 4채널 출력 (인터럽트) 
ISR(TIMER1_COMPA_vect) {
  
  digitalWrite(ROLL_PIN, HIGH);
  digitalWrite(PITCH_PIN, HIGH);
  digitalWrite(THROTTLE_PIN, HIGH);
  digitalWrite(YAW_PIN, HIGH);

  delayMicroseconds(roll_us);
  digitalWrite(ROLL_PIN, LOW);

  delayMicroseconds(pitch_us - roll_us);                                                     //완성 후 DDRx, PORTx 로 바꾸기
  digitalWrite(PITCH_PIN, LOW);

  delayMicroseconds(throttle_us - pitch_us);ss
  digitalWrite(THROTTLE_PIN, LOW);

  delayMicroseconds(yaw_us - throttle_us);
  digitalWrite(YAW_PIN, LOW);
}

// 문자열                                                                   //민우가 한 블루투스 확인해보고 함수 바꾸기, 보낸 데이터가 어떤 형식인지 같이 이야기
void parseCommand(String data) {
  data.trim();
  if (data.length() < 8) return;

  int tIdx = data.indexOf('T');
  int yIdx = data.indexOf('Y');
  int rIdx = data.indexOf('R');
  int pIdx = data.indexOf('P');

  if (tIdx != -1 && yIdx != -1)
    throttle_us = constrain(data.substring(tIdx + 1, yIdx).toInt(), 1000, 2000);
  if (yIdx != -1 && rIdx != -1)
    yaw_us = constrain(data.substring(yIdx + 1, rIdx).toInt(), 1000, 2000);
  if (rIdx != -1 && pIdx != -1)
    roll_us = constrain(data.substring(rIdx + 1, pIdx).toInt(), 1000, 2000);
  if (pIdx != -1)
    pitch_us = constrain(data.substring(pIdx + 1).toInt(), 1000, 2000);
}        */


/*

#define ROLL_PIN     9
#define PITCH_PIN    10
#define THROTTLE_PIN 3
#define YAW_PIN      5

int roll_us     = 1500;
int pitch_us    = 1500;
int throttle_us = 1000;
int yaw_us      = 1500;

unsigned long pwmStartTime = 0;
bool roll_high     = false;
bool pitch_high    = false;
bool throttle_high = false;
bool yaw_high      = false;

String inputString = "";

void setup() {
  Serial.begin(9600);
  pinMode(ROLL_PIN, OUTPUT);
  pinMode(PITCH_PIN, OUTPUT);
  pinMode(THROTTLE_PIN, OUTPUT);                                                           //완성 후 DDRx, PORTx 로 바꾸기
  pinMode(YAW_PIN, OUTPUT);
}

void loop() {
  // 1. 블루투스 수신
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n') {
      parseCommand(inputString);
      inputString = "";
    } else {
      inputString += c;
    }
  }

  // 2. non-blocking 방식 PWM
  unsigned long now = micros();

  // 2-1. 20ms 주기마다 PWM 신호 시작
  if (now - pwmStartTime >= 20000) {
    pwmStartTime = now;

    // 모든 채널 HIGH 시작
    digitalWrite(ROLL_PIN, HIGH);
    digitalWrite(PITCH_PIN, HIGH);
    digitalWrite(THROTTLE_PIN, HIGH);                                                       //완성 후 DDRx, PORTx 로 바꾸기
    digitalWrite(YAW_PIN, HIGH);

    roll_high = pitch_high = throttle_high = yaw_high = true;
  }

  // 2-2. 각 채널 개별로 LOW로 전환
  if (roll_high && (now - pwmStartTime >= roll_us)) {
    digitalWrite(ROLL_PIN, LOW);
    roll_high = false;
  }

  if (pitch_high && (now - pwmStartTime >= pitch_us)) {
    digitalWrite(PITCH_PIN, LOW);
    pitch_high = false;
  }

  if (throttle_high && (now - pwmStartTime >= throttle_us)) {
    digitalWrite(THROTTLE_PIN, LOW);
    throttle_high = false;
  }

  if (yaw_high && (now - pwmStartTime >= yaw_us)) {
    digitalWrite(YAW_PIN, LOW);
    yaw_high = false;
  }
}

void parseCommand(String data) {                                                              //민우가 한 블루투스 확인해보고 함수 바꾸기, 보낸 데이터가 어떤 형식인지 같이 이야기
  data.trim();
  if (data.length() < 8) return;

  int tIdx = data.indexOf('T');
  int yIdx = data.indexOf('Y');
  int rIdx = data.indexOf('R');
  int pIdx = data.indexOf('P');

  if (tIdx != -1 && yIdx != -1)
    throttle_us = constrain(data.substring(tIdx + 1, yIdx).toInt(), 1000, 2000);
  if (yIdx != -1 && rIdx != -1)
    yaw_us = constrain(data.substring(yIdx + 1, rIdx).toInt(), 1000, 2000);
  if (rIdx != -1 && pIdx != -1)
    roll_us = constrain(data.substring(rIdx + 1, pIdx).toInt(), 1000, 2000);
  if (pIdx != -1)
    pitch_us = constrain(data.substring(pIdx + 1).toInt(), 1000, 2000);
}
*/



#define ROLL_PIN     9
#define PITCH_PIN    10
#define THROTTLE_PIN 3
#define YAW_PIN      5

volatile int roll_us     = 1500;
volatile int pitch_us    = 1500;
volatile int throttle_us = 1000;
volatile int yaw_us      = 1500;

String inputString = "";

// 상태 플래그
volatile bool pwm_start_flag = false;

void setup() {
  Serial.begin(9600);

  pinMode(ROLL_PIN, OUTPUT);
  pinMode(PITCH_PIN, OUTPUT);
  pinMode(THROTTLE_PIN, OUTPUT);
  pinMode(YAW_PIN, OUTPUT);

  // Timer1 → 20ms마다 PWM 시작
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  TCCR1B |= (1 << WGM12);     // CTC 모드
  TCCR1B |= (1 << CS11);      // 프리스케일 8 (2MHz, 0.5us)
  OCR1A = 40000;              // 20ms
  TIMSK1 |= (1 << OCIE1A);    // 비교 인터럽트 허용
  sei();

  // Timer2 → 0.5us 단위에서 각 채널 LOW로 전환
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21);     // CTC 모드
  TCCR2B |= (1 << CS21);      // 프리스케일 8 (2MHz, 0.5us)
  OCR2A = 1;                  // 아주 빠르게 반복
  TIMSK2 |= (1 << OCIE2A);
}

void loop() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n') {
      parseCommand(inputString);
      inputString = "";
    } else {
      inputString += c;
    }
  }
}

ISR(TIMER1_COMPA_vect) {
  // 모든 채널 HIGH로 설정
  digitalWrite(ROLL_PIN, HIGH);
  digitalWrite(PITCH_PIN, HIGH);
  digitalWrite(THROTTLE_PIN, HIGH);
  digitalWrite(YAW_PIN, HIGH);
  pwm_start_flag = true;
  TCNT2 = 0;
}

ISR(TIMER2_COMPA_vect) {
  static int count_us = 0;

  if (!pwm_start_flag) return;

  count_us++;

  if (count_us == roll_us) {
    digitalWrite(ROLL_PIN, LOW);
  }
  if (count_us == pitch_us) {
    digitalWrite(PITCH_PIN, LOW);
  }
  if (count_us == throttle_us) {
    digitalWrite(THROTTLE_PIN, LOW);
  }
  if (count_us == yaw_us) {
    digitalWrite(YAW_PIN, LOW);
  }

  if (count_us >= 2000) { // 최대 2ms까지만 사용하고 나머지 시간은 대기
    count_us = 0;
    pwm_start_flag = false;
  }
}

void parseCommand(String data) {
  data.trim();
  if (data.length() < 8) return;

  int tIdx = data.indexOf('T');
  int yIdx = data.indexOf('Y');
  int rIdx = data.indexOf('R');
  int pIdx = data.indexOf('P');

  if (tIdx != -1 && yIdx != -1)
    throttle_us = constrain(data.substring(tIdx + 1, yIdx).toInt(), 1000, 2000);
  if (yIdx != -1 && rIdx != -1)
    yaw_us = constrain(data.substring(yIdx + 1, rIdx).toInt(), 1000, 2000);
  if (rIdx != -1 && pIdx != -1)
    roll_us = constrain(data.substring(rIdx + 1, pIdx).toInt(), 1000, 2000);
  if (pIdx != -1)
    pitch_us = constrain(data.substring(pIdx + 1).toInt(), 1000, 2000);
}

